#version 450 core

#include "util.glsl"

layout(set = 0, binding = 0, std140) uniform VolumeParams
{
    uvec4 volume_dims;
    uvec4 padded_dims;
    vec4 volume_scale;
    uint max_bits;
    float isovalue;
    uint image_width;
};

layout(set = 0, binding = 1, std140) uniform ViewParams
{
    mat4 proj_view;
    vec4 eye_pos;
    vec4 eye_dir;
    float near_plane;
};

layout(set = 0, binding = 2, std430) buffer BlockRanges
{
    BlockRange block_ranges[];
};

layout(set = 0, binding = 3, std430) buffer RayInformation
{
    RayInfo rays[];
};

uniform layout(set = 0, binding = 4, rgba8) writeonly image2D render_target;

layout(set = 1, binding = 0, std430) buffer VoxelInformation
{
    vec2 voxel_ranges[];
};

layout(set = 1, binding = 1, std430) buffer CoarseCellRange
{
    vec2 coarse_cell_ranges[];
};

vec4 block_id_to_color(const uvec3 block_id) {
    const vec3 n_blocks = padded_dims.xyz / uvec3(4);
    return vec4(vec3(block_id) / n_blocks, 1.0);
}

void main() {
    uint ray_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * image_width;

    if (rays[ray_index].t == FLT_MAX) {
        return;
    }

    const uvec3 n_blocks = padded_dims.xyz / uvec3(4);
    const ivec3 macrogrid_dims = ivec3(n_blocks);

    // Transform the ray into the dual grid space
    vec3 volume_translation = vec3(0) - volume_scale.xyz * 0.5;
	vec3 transformed_eye = (eye_pos.xyz - volume_translation) / volume_scale.xyz;
	vec3 vol_eye = transformed_eye * volume_dims.xyz - vec3(0.5);
    vec3 grid_ray_dir = rays[ray_index].ray_dir;

    // Transform to the macrocell grid
    // Note: ray dir is NOT normalized here, because the t values are relative
    // to the full volume grid.
    vol_eye *= 0.25;
    grid_ray_dir *= 0.25;

    GridIterator grid_iter = init_grid_iterator(vol_eye, grid_ray_dir, rays[ray_index].t, macrogrid_dims);
    ivec3 cell_id;
    vec2 cell_t_range;
    while (grid_iterator_next_cell(grid_iter, cell_t_range, cell_id)) {
        // Value range for a block is it's range combined with that of its neighbors to
        // the positive side 
        uint block_id = cell_id.x + n_blocks.x * (cell_id.y + n_blocks.y * cell_id.z);
        const vec2 cell_range = voxel_ranges[block_id];

        if (isovalue >= cell_range.x && isovalue <= cell_range.y) {
            rays[ray_index].block_id = block_id;
            rays[ray_index].t = cell_t_range.x;
            rays[ray_index].t_next = cell_t_range.y;
            return;
        }

    }

    rays[ray_index].block_id = UINT_MAX;
    rays[ray_index].t = FLT_MAX;
    // Rays that exit the macrocell grid write the background color
    imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(1));
}


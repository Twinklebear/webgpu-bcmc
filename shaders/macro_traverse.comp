#version 450 core

#include "util.glsl"

layout(set = 0, binding = 0, std140) uniform VolumeParams
{
    uvec4 volume_dims;
    uvec4 padded_dims;
    vec4 volume_scale;
    uint max_bits;
    float isovalue;
    uint image_width;
};

layout(set = 0, binding = 1, std140) uniform ViewParams {
    mat4 proj_view;
    vec4 eye_pos;
};

layout(set = 0, binding = 2, std430) buffer BlockRanges
{
    vec2 block_ranges[];
};

layout(set = 0, binding = 3, std430) buffer RayInformation {
    RayInfo rays[];
};

uniform layout(set = 0, binding = 4, rgba8) writeonly image2D render_target;

bool outside_dual_grid(const vec3 p, const vec3 grid_dims) {
    return any(lessThan(p, vec3(0))) || any(greaterThanEqual(p, grid_dims));
}

vec3 hsl2rgb(in vec3 c) {
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);

    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
}

vec4 block_id_to_color(const uvec3 block_id) {
    const vec3 n_blocks = padded_dims.xyz / uvec3(4);
    return vec4(vec3(block_id) / n_blocks, 1.0);
}

void main() {
    uint ray_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * image_width;

    if (rays[ray_index].t == FLT_MAX) {
        imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(0.1, 0.1, 0.1, 1.0));
        return;
    }
        imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(0, 0, 0, 1.0));
    
    const uvec3 n_blocks = padded_dims.xyz / uvec3(4);
    const vec3 macrogrid_dims = vec3(n_blocks);

    // Transform the ray into the dual grid space
    vec3 volume_translation = vec3(0) - volume_scale.xyz * 0.5;
	vec3 transformed_eye = (eye_pos.xyz - volume_translation) / volume_scale.xyz;
	vec3 vol_eye = transformed_eye * volume_dims.xyz - vec3(0.5);
    vec3 grid_ray_dir = normalize(rays[ray_index].ray_dir * volume_dims.xyz);

    // Transform to the macrocell grid
    // Note: ray dir is NOT normalized here, because the t values are relative
    // to the full volumue grid.
    vol_eye *= 0.25;
    grid_ray_dir *= 0.25;

	vec3 p = (vol_eye + rays[ray_index].t * grid_ray_dir);
    p = clamp(p, vec3(0), vec3(macrogrid_dims - 1));

    const vec3 inv_grid_ray_dir = 1.0 / grid_ray_dir;
    const vec3 start_cell = floor(p);
    const vec3 t_max_neg = (start_cell - vol_eye) * inv_grid_ray_dir;
    const vec3 t_max_pos = (start_cell + vec3(1) - vol_eye) * inv_grid_ray_dir;
    const bvec3 is_neg_dir = lessThan(grid_ray_dir, vec3(0));
    // Pick between positive/negative t_max based on the ray sign
    vec3 t_max = mix(t_max_pos, t_max_neg, is_neg_dir);
    const ivec3 grid_step = ivec3(sign(grid_ray_dir));
    // Note: each voxel is a 1^3 box on the grid
    const vec3 t_delta = abs(inv_grid_ray_dir);

    float t_prev = rays[ray_index].t;
    // Traverse the grid 
    while (!outside_dual_grid(p, macrogrid_dims)) {
        const ivec3 block_pos = ivec3(p);

        uint block_id = block_pos.x + n_blocks.x * (block_pos.y + n_blocks.y * block_pos.z);
        vec2 cell_range = block_ranges[block_id];
        if (isovalue >= cell_range.x && isovalue <= cell_range.y) {
            rays[ray_index].block_id = block_id;
            rays[ray_index].t = t_prev;

            imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), block_id_to_color(block_pos));
            return;
        }

        t_prev = min(t_max.x, min(t_max.y, t_max.z));

        // Advance in the grid
        if (t_prev == t_max.x) {
            p.x += grid_step.x;
            t_max.x += t_delta.x;
        } else if (t_prev == t_max.y) {
            p.y += grid_step.y;
            t_max.y += t_delta.y;
        } else {
            p.z += grid_step.z;
            t_max.z += t_delta.z;
        }
    }
    rays[ray_index].block_id = UINT_MAX;
    rays[ray_index].t = FLT_MAX;
}

